---
phase: 02-speech-recognition-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - voice/SpeechRecognizer.js
autonomous: true

must_haves:
  truths:
    - "Speech recognition starts when start() is called"
    - "Recognition auto-restarts when session ends"
    - "Errors are categorized as recoverable or fatal"
    - "Callbacks fire for transcript, error, and state changes"
  artifacts:
    - path: "voice/SpeechRecognizer.js"
      provides: "Speech recognition wrapper with auto-restart"
      exports: ["SpeechRecognizer"]
      min_lines: 80
  key_links:
    - from: "voice/SpeechRecognizer.js"
      to: "window.SpeechRecognition"
      via: "new SpeechRecognition()"
      pattern: "new.*SpeechRecognition"
---

<objective>
Create a reusable SpeechRecognizer module that wraps the Web Speech API with continuous recognition, auto-restart on session end, and proper error categorization.

Purpose: This module provides the core speech recognition capability for Phase 2. It handles the complexity of continuous listening (Chrome's 60-second timeout, 7-second silence detection) and error recovery, exposing a clean interface for the UI layer.

Output: A standalone JavaScript module (voice/SpeechRecognizer.js) that can be imported and used by the main application.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-speech-recognition-foundation/02-CONTEXT.md
@.planning/phases/02-speech-recognition-foundation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SpeechRecognizer module with browser support check</name>
  <files>voice/SpeechRecognizer.js</files>
  <action>
Create the voice/ directory and SpeechRecognizer.js module.

The module should:
1. Check for browser support at module load time (window.SpeechRecognition || window.webkitSpeechRecognition)
2. Export an `isSupported()` function that returns boolean
3. Export a `SpeechRecognizer` class with this interface:

```javascript
class SpeechRecognizer {
  constructor(options = {})  // options: { lang: 'en-US', onTranscript, onError, onStateChange }
  start()                    // Request mic permission (if not granted) and start recognition
  stop()                     // Stop recognition and cleanup
  isListening()              // Returns boolean
}
```

Callback signatures:
- onTranscript(text, isFinal) - text is transcript string, isFinal is boolean
- onError(errorType, isFatal) - errorType is string, isFatal is boolean
- onStateChange(state) - state is 'idle' | 'listening' | 'error' | 'retrying'

Configuration in constructor:
- recognition.continuous = true
- recognition.interimResults = true
- recognition.lang = options.lang || 'en-US'

Error categorization (from RESEARCH.md):
- RECOVERABLE: 'network', 'no-speech', 'aborted' -> auto-retry with backoff
- FATAL: 'not-allowed', 'service-not-allowed', 'language-not-supported' -> stop, notify

Auto-restart behavior:
- In onend handler, restart with 100ms delay if still supposed to be listening
- Track intentional stops vs session timeouts
- Reset retry counter on successful start

Backoff strategy for recoverable errors:
- Exponential: 100ms, 200ms, 400ms, 800ms, etc.
- Max delay: 5000ms
- Retry indefinitely (per CONTEXT.md user decision)
- Call onStateChange('retrying') during retry attempts

Do NOT request getUserMedia here - that's handled separately for the audio visualizer.
The recognition.start() will trigger browser's mic permission if not already granted.
  </action>
  <verify>
1. Create a test HTML file that imports the module
2. Call isSupported() and log result
3. Create instance with onTranscript logging
4. Verify no runtime errors on module load
  </verify>
  <done>
- SpeechRecognizer module exists at voice/SpeechRecognizer.js
- isSupported() returns true in Chrome/Safari, false in Firefox
- Class instantiates without error
- Callbacks receive expected arguments when recognition runs
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auto-restart and retry logic</name>
  <files>voice/SpeechRecognizer.js</files>
  <action>
Enhance the SpeechRecognizer with robust auto-restart and retry behavior.

Add internal state tracking:
- this._shouldBeListening (boolean) - true between start() and stop()
- this._retryCount (number) - current retry attempt
- this._retryTimeout (timeout id) - for cleanup

In recognition.onend handler:
```javascript
if (this._shouldBeListening) {
  // Session ended but we want to keep listening (Chrome 60s timeout or 7s silence)
  this._scheduleRestart();
}
```

In recognition.onerror handler:
```javascript
const RECOVERABLE = ['network', 'no-speech', 'aborted'];
const FATAL = ['not-allowed', 'service-not-allowed', 'language-not-supported'];

if (FATAL.includes(event.error)) {
  this._shouldBeListening = false;
  this._options.onStateChange?.('error');
  this._options.onError?.(event.error, true);
} else if (RECOVERABLE.includes(event.error)) {
  this._options.onStateChange?.('retrying');
  this._options.onError?.(event.error, false);
  // Don't call _scheduleRestart here - onend will fire after onerror
}
```

The _scheduleRestart method:
```javascript
_scheduleRestart() {
  const delay = Math.min(100 * Math.pow(2, this._retryCount), 5000);
  this._retryCount++;

  this._retryTimeout = setTimeout(() => {
    if (this._shouldBeListening) {
      try {
        this._recognition.start();
      } catch (e) {
        // Handle "already started" edge case
        console.warn('Recognition already started');
      }
    }
  }, delay);
}
```

In recognition.onstart handler:
```javascript
this._retryCount = 0;  // Reset on successful start
this._options.onStateChange?.('listening');
```

In stop() method:
```javascript
stop() {
  this._shouldBeListening = false;
  clearTimeout(this._retryTimeout);
  this._recognition.stop();
  this._options.onStateChange?.('idle');
}
```

Handle edge case where onerror fires but onend doesn't (rare but possible):
- Set a safety timeout after onerror that triggers restart if onend hasn't fired
  </action>
  <verify>
1. Start recognition, speak, verify transcript callback fires
2. Stay silent for 10+ seconds, verify auto-restart (onend -> restart)
3. Disconnect network briefly (if possible) or simulate network error
4. Verify retry attempts with increasing delays (check console logs)
  </verify>
  <done>
- Recognition continues through silence (auto-restarts)
- Recoverable errors trigger retry with backoff
- Fatal errors stop recognition and report via callback
- stop() cleanly terminates all pending retries
  </done>
</task>

</tasks>

<verification>
Manual testing checklist:
1. Open in Chrome - isSupported() returns true
2. Open in Firefox - isSupported() returns false
3. Start recognition - mic permission prompt appears (first time)
4. Speak - transcript appears in console
5. Wait silently 10+ seconds - recognition restarts automatically
6. Call stop() - recognition stops, no more restarts
7. Deny mic permission on fresh instance - onError fires with 'not-allowed', isFatal=true
</verification>

<success_criteria>
- SpeechRecognizer module is self-contained with no UI dependencies
- Auto-restart handles Chrome's 60-second session timeout transparently
- Error categorization correctly identifies fatal vs recoverable errors
- Clean interface suitable for integration with UI in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/02-speech-recognition-foundation/02-01-SUMMARY.md`
</output>
