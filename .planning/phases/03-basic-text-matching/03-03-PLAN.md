---
phase: 03-basic-text-matching
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - script.js
  - index.html
  - matching/ScrollSync.js
autonomous: false

must_haves:
  truths:
    - "User speaks words from script and app scrolls to matching position"
    - "User can paraphrase slightly and app still finds approximate match"
    - "App highlights current matched position in the script"
    - "Highlighting toggle persists across sessions"
    - "Manual scroll controls coexist with voice control"
  artifacts:
    - path: "matching/ScrollSync.js"
      provides: "Scroll synchronization to matched position"
      exports: ["ScrollSync"]
    - path: "script.js"
      provides: "Main app with voice-to-scroll integration"
      contains: "TextMatcher"
  key_links:
    - from: "script.js"
      to: "SpeechRecognizer.onTranscript"
      via: "callback wiring"
      pattern: "onTranscript.*TextMatcher"
    - from: "script.js"
      to: "matching/ScrollSync.js"
      via: "import and scroll calls"
      pattern: "scrollSync\\.scrollTo"
    - from: "script.js"
      to: "matching/Highlighter.js"
      via: "import and highlight calls"
      pattern: "highlighter\\.highlightPosition"
---

<objective>
Wire TextMatcher, Highlighter, and ScrollSync together with SpeechRecognizer to create the complete voice-controlled scrolling experience.

Purpose: This is the integration that makes the teleprompter "follow you" - connecting voice input to text matching to scroll position to visual feedback.
Output: Working voice-to-scroll feature where speaking advances the teleprompter automatically
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-basic-text-matching/03-CONTEXT.md
@.planning/phases/03-basic-text-matching/03-RESEARCH.md
@.planning/phases/02-speech-recognition-foundation/02-03-SUMMARY.md
@script.js
@voice/SpeechRecognizer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScrollSync module</name>
  <files>matching/ScrollSync.js</files>
  <action>
Create `matching/ScrollSync.js` that:
1. Calculates scroll position based on word index
2. Smoothly animates to position using native scrollIntoView or scroll-behavior
3. Keeps matched text at reading marker position (center of viewport)
4. Auto-adjusts scroll speed to match speaking pace

```javascript
// Scroll synchronization module
// Scrolls teleprompter to keep matched position at reading marker

export class ScrollSync {
  constructor(containerElement, textElement, options = {}) {
    this.container = containerElement;
    this.textElement = textElement;

    // Animation timing from CONTEXT.md: 200-500ms smooth animation
    this.scrollDuration = options.scrollDuration || 300;

    // Track speaking pace for adaptive scroll
    this.lastScrollTime = 0;
    this.lastPosition = 0;
    this.speakingPace = 0;  // words per second

    // For cancelling in-progress scrolls
    this.scrollAnimationId = null;
  }

  // Scroll to word position in script
  scrollToWordIndex(wordIndex, totalWords) {
    if (wordIndex < 0 || totalWords <= 0) return;

    // Calculate progress through script (0 to 1)
    const progress = wordIndex / totalWords;

    // Calculate target scroll position
    // Total scrollable distance = scrollHeight - clientHeight
    const maxScroll = this.container.scrollHeight - this.container.clientHeight;
    const targetScroll = Math.round(progress * maxScroll);

    // Track pace for future adaptive scrolling
    this.updateSpeakingPace(wordIndex);

    // Smooth scroll to position
    this.smoothScrollTo(targetScroll);
  }

  // Smooth scroll animation using native scroll-behavior
  smoothScrollTo(targetTop) {
    // Cancel any in-progress animation
    if (this.scrollAnimationId) {
      cancelAnimationFrame(this.scrollAnimationId);
    }

    const startTop = this.container.scrollTop;
    const distance = targetTop - startTop;

    // Skip if already at target or very small movement
    if (Math.abs(distance) < 5) return;

    const startTime = performance.now();
    const duration = this.scrollDuration;

    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Ease-out cubic for smooth deceleration
      const eased = 1 - Math.pow(1 - progress, 3);

      this.container.scrollTop = startTop + (distance * eased);

      if (progress < 1) {
        this.scrollAnimationId = requestAnimationFrame(animate);
      } else {
        this.scrollAnimationId = null;
      }
    };

    this.scrollAnimationId = requestAnimationFrame(animate);
  }

  // Track speaking pace for adaptive behavior (Phase 4)
  updateSpeakingPace(wordIndex) {
    const now = Date.now();

    if (this.lastScrollTime > 0) {
      const timeDelta = (now - this.lastScrollTime) / 1000;  // seconds
      const wordsDelta = wordIndex - this.lastPosition;

      if (timeDelta > 0 && wordsDelta > 0) {
        // Smoothed pace calculation
        const instantPace = wordsDelta / timeDelta;
        this.speakingPace = this.speakingPace * 0.7 + instantPace * 0.3;
      }
    }

    this.lastScrollTime = now;
    this.lastPosition = wordIndex;
  }

  // Get current speaking pace (for future confidence/speed logic)
  getSpeakingPace() {
    return this.speakingPace;
  }

  // Stop any in-progress scroll animation
  stop() {
    if (this.scrollAnimationId) {
      cancelAnimationFrame(this.scrollAnimationId);
      this.scrollAnimationId = null;
    }
  }

  // Reset state (e.g., when script changes)
  reset() {
    this.stop();
    this.lastScrollTime = 0;
    this.lastPosition = 0;
    this.speakingPace = 0;
  }
}
```

Key design decisions per CONTEXT.md:
- Smooth animation 200-500ms (default 300ms)
- Tracks speaking pace for future Phase 4 adaptive scrolling
- Uses ease-out cubic for natural deceleration
  </action>
  <verify>
- `cat matching/ScrollSync.js` shows ScrollSync class
- Has scrollToWordIndex, smoothScrollTo, reset methods
- Uses requestAnimationFrame for smooth animation
  </verify>
  <done>ScrollSync module created with smooth scroll animation and speaking pace tracking</done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching system into main app</name>
  <files>script.js, index.html</files>
  <action>
Modify script.js to:
1. Import TextMatcher, Highlighter, ScrollSync modules
2. Initialize them when entering teleprompter mode with script
3. Wire SpeechRecognizer.onTranscript to TextMatcher
4. Wire TextMatcher matches to ScrollSync and Highlighter
5. Add highlight toggle control and persistence

**In index.html**, add module script tags before main script:

```html
<!-- Matching modules -->
<script type="module" src="matching/textUtils.js"></script>
<script type="module" src="matching/TextMatcher.js"></script>
<script type="module" src="matching/Highlighter.js"></script>
<script type="module" src="matching/ScrollSync.js"></script>
```

Wait, we need to convert to ES modules or use a different approach. Since the existing code uses script tags without modules, we have two options:

**Option A:** Convert entire app to ES modules (larger change)
**Option B:** Use dynamic import() in script.js (cleaner for incremental change)

Use Option B - dynamic imports:

**In script.js**, make these changes:

1. At the top, add module variables:
```javascript
// Matching system components (loaded dynamically as ES modules)
let TextMatcher = null;
let Highlighter = null;
let ScrollSync = null;
let textMatcher = null;
let highlighter = null;
let scrollSync = null;
```

2. Add state properties:
```javascript
// In createState initialState, add:
highlightEnabled: true,  // Show text highlighting
```

3. Add SETTINGS_KEY handling for highlightEnabled.

4. Create initialization function:
```javascript
async function initMatchingSystem(scriptText) {
  // Dynamic import of ES modules
  if (!TextMatcher) {
    const textUtils = await import('./matching/textUtils.js');
    const matcherModule = await import('./matching/TextMatcher.js');
    const highlightModule = await import('./matching/Highlighter.js');
    const scrollModule = await import('./matching/ScrollSync.js');

    TextMatcher = matcherModule.TextMatcher;
    Highlighter = highlightModule.Highlighter;
    ScrollSync = scrollModule.ScrollSync;
  }

  // Initialize with current script
  textMatcher = new TextMatcher(scriptText, {
    windowSize: 3,
    threshold: 0.3,
    minConsecutiveMatches: 2
  });

  highlighter = new Highlighter(teleprompterText, {
    phraseLength: 3,
    enabled: state.highlightEnabled
  });

  scrollSync = new ScrollSync(teleprompterContainer, teleprompterText, {
    scrollDuration: 300
  });

  console.log('[Matching] System initialized with', textMatcher.scriptWords.length, 'words');
}
```

5. Update enableVoiceMode to wire transcript to matcher:
```javascript
// Replace the existing onTranscript callback:
onTranscript: (text, isFinal) => {
  console.log(`[Voice] ${isFinal ? 'FINAL' : 'interim'}: ${text}`);

  // Process transcript through matcher
  if (textMatcher && isFinal) {
    const match = textMatcher.processTranscript(text);
    if (match !== null) {
      console.log(`[Matching] Position: ${match}/${textMatcher.scriptWords.length}`);

      // Update scroll position
      if (scrollSync) {
        scrollSync.scrollToWordIndex(match, textMatcher.scriptWords.length);
      }

      // Update highlight
      if (highlighter) {
        highlighter.highlightPosition(match, textMatcher.scriptWords);
      }
    }
  }
},
```

6. Update switchMode to initialize matching on teleprompter entry:
```javascript
// In switchMode('teleprompter') section, after setting teleprompterText.textContent:
// Initialize matching system
initMatchingSystem(scriptContent).catch(err => {
  console.error('[Matching] Init failed:', err);
});
```

7. Add cleanup in switchMode('editor'):
```javascript
// Clean up matching system
if (textMatcher) {
  textMatcher.reset();
}
if (highlighter) {
  highlighter.clear();
}
if (scrollSync) {
  scrollSync.reset();
}
```

8. Add highlight toggle function and button handler:
```javascript
function toggleHighlight() {
  state.highlightEnabled = !state.highlightEnabled;
  if (highlighter) {
    highlighter.setEnabled(state.highlightEnabled);
  }
  updateHighlightButton();
}

function updateHighlightButton() {
  const btn = document.getElementById('highlight-toggle');
  if (btn) {
    btn.classList.toggle('active', state.highlightEnabled);
  }
}
```

9. Add highlight toggle button to index.html controls:
```html
<button id="highlight-toggle" class="control-btn active" title="Toggle text highlighting">Highlight</button>
```

10. Wire up button in DOMContentLoaded:
```javascript
const highlightToggle = document.getElementById('highlight-toggle');
if (highlightToggle) {
  highlightToggle.addEventListener('click', toggleHighlight);
}
```

11. Update saveSettings/loadSettings to include highlightEnabled.

**Full integration means**: When user speaks, transcript goes to TextMatcher, match position goes to ScrollSync (scroll) and Highlighter (visual).
  </action>
  <verify>
- `grep "TextMatcher" script.js` shows import and usage
- `grep "highlightEnabled" script.js` shows state property and persistence
- `grep "highlight-toggle" index.html` shows button added
- `grep "processTranscript" script.js` shows wiring in onTranscript callback
  </verify>
  <done>TextMatcher, Highlighter, and ScrollSync integrated into main app with voice transcript wiring</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete voice-to-scroll integration:
- TextMatcher fuzzy matches spoken words to script position
- Highlighter shows current phrase and dims previous text
- ScrollSync smoothly scrolls to matched position
- Toggle for highlighting preference with persistence
  </what-built>
  <how-to-verify>
1. Start local server: `npx serve .` or `python3 -m http.server 8000`
2. Open http://localhost:8000 (or port 3000 if using npx serve)
3. Paste sample script into editor (use text from test-matcher.html or your own)
4. Click "Start" to enter teleprompter mode
5. Click "Voice" button to enable voice mode (grant microphone permission)
6. Start speaking words from the script

**Verify these behaviors:**
- [ ] Speaking words from script causes teleprompter to scroll
- [ ] Scroll follows your speaking position (not fixed speed)
- [ ] Current phrase is highlighted (light blue tint)
- [ ] Previously read text is dimmed (lower opacity)
- [ ] Paraphrasing still matches (e.g., "gonna" for "going to")
- [ ] Filler words ("um", "uh", "like") are ignored
- [ ] Highlight toggle button works (turns highlighting on/off)
- [ ] Manual scroll controls still work alongside voice
- [ ] Exiting to editor clears highlighting

**Edge cases to test:**
- Speak quickly - scroll should keep up
- Speak slowly - no erratic behavior
- Stop speaking - highlight stays at last position
- Speak different section - scroll should jump to new position (may take 2-3 words)
  </how-to-verify>
  <resume-signal>Type "approved" if voice-controlled scrolling works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After human verification approved:

1. Integration check:
   - Voice mode + matching system work together
   - Scroll follows spoken position
   - Highlight shows current position

2. Requirements check (TRACK-01):
   - App matches spoken words to script position
   - Semantic matching handles paraphrasing
   - Visual feedback via highlighting
</verification>

<success_criteria>
- ScrollSync module created with smooth scroll animation
- TextMatcher, Highlighter, ScrollSync integrated into script.js
- SpeechRecognizer.onTranscript wired to matching system
- Highlight toggle added with persistence
- Human verification confirms voice-controlled scrolling works
- Phase 3 requirements (TRACK-01) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-basic-text-matching/03-03-SUMMARY.md`
</output>
