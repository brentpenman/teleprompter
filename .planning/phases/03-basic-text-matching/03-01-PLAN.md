---
phase: 03-basic-text-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - matching/TextMatcher.js
  - matching/textUtils.js
autonomous: true

must_haves:
  truths:
    - "Spoken words are fuzzy-matched against script text"
    - "Filler words are ignored during matching"
    - "Numbers are normalized to word equivalents"
    - "Consecutive word matches confirm position"
  artifacts:
    - path: "matching/TextMatcher.js"
      provides: "Fuzzy text matching with sliding window"
      exports: ["TextMatcher"]
    - path: "matching/textUtils.js"
      provides: "Text normalization utilities"
      exports: ["normalizeText", "normalizeNumber", "isFillerWord"]
    - path: "package.json"
      provides: "Project dependencies"
      contains: "fuse.js"
  key_links:
    - from: "matching/TextMatcher.js"
      to: "fuse.js"
      via: "import and search"
      pattern: "Fuse.*search"
---

<objective>
Create the text matching engine that fuzzy-matches spoken words to script positions using a sliding window pattern.

Purpose: This is the core intelligence that enables voice-controlled scrolling - it determines where in the script the user is currently speaking.
Output: TextMatcher module with fuzzy matching, filler word filtering, and number normalization
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-basic-text-matching/03-CONTEXT.md
@.planning/phases/03-basic-text-matching/03-RESEARCH.md
@script.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create text utilities</name>
  <files>package.json, matching/textUtils.js</files>
  <action>
1. Initialize npm if needed: `npm init -y` (only if package.json doesn't exist)
2. Install fuzzy matching library: `npm install fuse.js`
3. Install stopword library: `npm install stopword`
4. Create `matching/textUtils.js` with:

```javascript
// Text normalization utilities for matching
import { removeStopwords, eng } from 'stopword';

// Custom filler words to ignore (speech artifacts)
const FILLER_WORDS = ['um', 'uh', 'like', 'you know', 'actually', 'basically', 'so', 'well'];

// Number word mappings (0-100 + common large numbers)
const NUMBER_WORDS = {
  '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
  '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine',
  '10': 'ten', '11': 'eleven', '12': 'twelve', '13': 'thirteen',
  '14': 'fourteen', '15': 'fifteen', '16': 'sixteen', '17': 'seventeen',
  '18': 'eighteen', '19': 'nineteen', '20': 'twenty', '30': 'thirty',
  '40': 'forty', '50': 'fifty', '60': 'sixty', '70': 'seventy',
  '80': 'eighty', '90': 'ninety', '100': 'hundred', '1000': 'thousand'
};

export function normalizeText(text) {
  return text
    .toLowerCase()
    .replace(/[.,!?;:'"()\[\]{}]/g, '')  // Remove punctuation
    .normalize('NFC')  // Unicode normalization
    .trim();
}

export function normalizeNumber(text) {
  // Replace digits with word equivalents where known
  return text.replace(/\b\d+\b/g, (match) => {
    return NUMBER_WORDS[match] || match;
  });
}

export function isFillerWord(word) {
  const normalized = word.toLowerCase().trim();
  return FILLER_WORDS.includes(normalized);
}

export function filterFillerWords(words) {
  // Remove both standard English stopwords and custom fillers
  const customFillers = FILLER_WORDS;
  const allStopwords = [...eng, ...customFillers];
  return removeStopwords(words, allStopwords);
}

export function tokenize(text) {
  const normalized = normalizeNumber(normalizeText(text));
  return normalized.split(/\s+/).filter(w => w.length > 0);
}
```

Note: Use ES modules syntax. These utilities will be imported by TextMatcher.
  </action>
  <verify>
- `cat package.json` shows fuse.js and stopword in dependencies
- `cat matching/textUtils.js` shows exports for normalizeText, normalizeNumber, isFillerWord, filterFillerWords, tokenize
  </verify>
  <done>Dependencies installed, text utilities module created with normalization and filtering functions</done>
</task>

<task type="auto">
  <name>Task 2: Create TextMatcher with sliding window pattern</name>
  <files>matching/TextMatcher.js</files>
  <action>
Create `matching/TextMatcher.js` implementing:

1. Constructor accepts script text and options (windowSize, threshold)
2. Uses Fuse.js for fuzzy search with threshold ~0.3 (lower = stricter)
3. Maintains sliding window buffer of recent spoken words (default: 3)
4. Requires 2+ consecutive matches to confirm position
5. Searches forward from current position first (performance + handles repeated phrases)
6. Falls back to backward search if no forward match

```javascript
import Fuse from 'fuse.js';
import { tokenize, filterFillerWords, isFillerWord } from './textUtils.js';

export class TextMatcher {
  constructor(scriptText, options = {}) {
    this.windowSize = options.windowSize || 3;
    this.threshold = options.threshold || 0.3;  // Fuse.js: 0 = exact, 1 = match anything
    this.minConsecutiveMatches = options.minConsecutiveMatches || 2;

    // Tokenize script into searchable words
    this.scriptWords = tokenize(scriptText);
    this.originalScript = scriptText;

    // Build Fuse index
    this.scriptIndex = this.scriptWords.map((word, index) => ({
      word,
      index
    }));

    this.fuse = new Fuse(this.scriptIndex, {
      keys: ['word'],
      threshold: this.threshold,
      includeScore: true,
      findAllMatches: false,
      minMatchCharLength: 2
    });

    // State
    this.spokenBuffer = [];  // Recent spoken words
    this.currentPosition = 0;  // Current match position in script
    this.lastMatchTime = 0;
  }

  // Add a spoken word and try to find match
  addSpokenWord(word) {
    // Filter filler words
    if (isFillerWord(word)) {
      return null;
    }

    const normalized = tokenize(word)[0];
    if (!normalized) return null;

    // Add to buffer
    this.spokenBuffer.push(normalized);

    // Maintain window size
    if (this.spokenBuffer.length > this.windowSize) {
      this.spokenBuffer.shift();
    }

    // Need at least 2 words to match
    if (this.spokenBuffer.length < this.minConsecutiveMatches) {
      return null;
    }

    // Try to find consecutive match
    const match = this.findConsecutiveMatch();
    if (match !== null) {
      this.currentPosition = match;
      this.lastMatchTime = Date.now();
      return match;
    }

    return null;
  }

  // Process a transcript (may contain multiple words)
  processTranscript(transcript) {
    const words = tokenize(transcript);
    const filtered = filterFillerWords(words);

    let lastMatch = null;
    for (const word of filtered) {
      const match = this.addSpokenWord(word);
      if (match !== null) {
        lastMatch = match;
      }
    }

    return lastMatch;
  }

  findConsecutiveMatch() {
    const window = this.spokenBuffer;

    // Search forward from current position first
    let match = this.searchRange(this.currentPosition, this.scriptWords.length, window);
    if (match !== null) return match;

    // Search backward (in case user jumped back)
    match = this.searchRange(0, this.currentPosition, window);
    return match;
  }

  searchRange(start, end, window) {
    for (let i = start; i < end - window.length + 1; i++) {
      let matchCount = 0;

      for (let j = 0; j < window.length; j++) {
        const results = this.fuse.search(window[j]);

        // Check if any result matches position i + j
        const hasMatch = results.some(r =>
          r.item.index === i + j && r.score <= this.threshold
        );

        if (hasMatch) {
          matchCount++;
        }
      }

      // Require minConsecutiveMatches out of window
      if (matchCount >= this.minConsecutiveMatches) {
        return i;
      }
    }

    return null;
  }

  // Get word position info for highlighting
  getPositionInfo(wordIndex) {
    if (wordIndex < 0 || wordIndex >= this.scriptWords.length) {
      return null;
    }

    // Calculate character offset in original script
    // This is approximate - for exact highlighting, we'll need char positions
    return {
      wordIndex,
      word: this.scriptWords[wordIndex],
      totalWords: this.scriptWords.length,
      progress: wordIndex / this.scriptWords.length
    };
  }

  // Reset state (e.g., when script changes)
  reset() {
    this.spokenBuffer = [];
    this.currentPosition = 0;
    this.lastMatchTime = 0;
  }

  // Get current state for debugging
  getState() {
    return {
      currentPosition: this.currentPosition,
      buffer: [...this.spokenBuffer],
      scriptLength: this.scriptWords.length
    };
  }
}
```

Key design decisions per CONTEXT.md:
- Hybrid approach: individual word matching + consecutive confirmation
- Very fuzzy matching (threshold 0.3 is quite permissive)
- Filler words filtered before matching
- Forward search first for performance and repeated phrase handling
  </action>
  <verify>
- `cat matching/TextMatcher.js` shows TextMatcher class with constructor, addSpokenWord, processTranscript, findConsecutiveMatch methods
- Class imports from textUtils.js and fuse.js
  </verify>
  <done>TextMatcher module created with sliding window pattern, fuzzy matching via Fuse.js, and consecutive match confirmation</done>
</task>

<task type="auto">
  <name>Task 3: Create test page for TextMatcher</name>
  <files>test-matcher.html</files>
  <action>
Create a standalone test page that:
1. Loads TextMatcher and dependencies
2. Has a textarea for script input
3. Has a text input for simulating spoken words
4. Shows match results and current position

This validates the matching logic before integration with voice.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TextMatcher Test</title>
  <style>
    body { font-family: system-ui; padding: 20px; max-width: 800px; margin: 0 auto; }
    textarea { width: 100%; height: 150px; margin-bottom: 10px; }
    input { width: 300px; padding: 8px; margin-right: 10px; }
    button { padding: 8px 16px; }
    .result { margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 8px; }
    .match { color: green; font-weight: bold; }
    .no-match { color: #888; }
    .highlight { background: yellow; padding: 2px 4px; }
    #script-display { white-space: pre-wrap; line-height: 1.8; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>TextMatcher Test</h1>

  <h3>1. Enter Script</h3>
  <textarea id="script-input" placeholder="Paste your script here...">Welcome to our presentation today. We will discuss the importance of voice recognition technology and how it can transform the way we interact with applications.</textarea>
  <button id="load-script">Load Script</button>

  <h3>2. Simulate Spoken Words</h3>
  <input type="text" id="spoken-input" placeholder="Type words as if speaking...">
  <button id="process-word">Process</button>
  <button id="reset">Reset</button>

  <div class="result">
    <h4>State</h4>
    <div id="state-display">No script loaded</div>
  </div>

  <h3>3. Script with Position</h3>
  <div id="script-display"></div>

  <script type="module">
    import { TextMatcher } from './matching/TextMatcher.js';

    let matcher = null;

    const scriptInput = document.getElementById('script-input');
    const spokenInput = document.getElementById('spoken-input');
    const stateDisplay = document.getElementById('state-display');
    const scriptDisplay = document.getElementById('script-display');

    function updateDisplay() {
      if (!matcher) {
        stateDisplay.textContent = 'No script loaded';
        return;
      }

      const state = matcher.getState();
      stateDisplay.innerHTML = `
        <strong>Position:</strong> ${state.currentPosition} / ${state.scriptLength}<br>
        <strong>Buffer:</strong> [${state.buffer.join(', ')}]<br>
        <strong>Progress:</strong> ${Math.round(state.currentPosition / state.scriptLength * 100)}%
      `;

      // Highlight current position in script
      const words = scriptInput.value.split(/\s+/);
      const highlighted = words.map((word, i) => {
        if (i === state.currentPosition) {
          return `<span class="highlight">${word}</span>`;
        }
        if (i < state.currentPosition) {
          return `<span style="opacity: 0.5">${word}</span>`;
        }
        return word;
      }).join(' ');

      scriptDisplay.innerHTML = highlighted;
    }

    document.getElementById('load-script').addEventListener('click', () => {
      const script = scriptInput.value;
      matcher = new TextMatcher(script);
      updateDisplay();
      console.log('Script loaded with', matcher.scriptWords.length, 'words');
    });

    document.getElementById('process-word').addEventListener('click', () => {
      if (!matcher) {
        alert('Load script first!');
        return;
      }

      const words = spokenInput.value;
      const match = matcher.processTranscript(words);

      if (match !== null) {
        console.log('Match found at position:', match);
      } else {
        console.log('No match yet');
      }

      updateDisplay();
      spokenInput.value = '';
      spokenInput.focus();
    });

    document.getElementById('reset').addEventListener('click', () => {
      if (matcher) {
        matcher.reset();
        updateDisplay();
      }
    });

    // Allow Enter key to process
    spokenInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('process-word').click();
      }
    });
  </script>
</body>
</html>
```

Test cases to verify manually:
1. Load script, type "Welcome to our" -> should match position 0
2. Type "presentation today" -> should advance to ~position 3
3. Type "um uh like" -> should be ignored (filler words)
4. Type "voyce recognishun" -> should still match "voice recognition" (fuzzy)
  </action>
  <verify>
- `cat test-matcher.html` shows test page with script input, spoken word input, and state display
- Open in browser (via local server) and test matching behavior
  </verify>
  <done>Test page created for validating TextMatcher before voice integration</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Dependencies check:
   - `npm ls fuse.js` shows installed
   - `npm ls stopword` shows installed

2. Module structure:
   - `ls matching/` shows TextMatcher.js and textUtils.js

3. Functional test:
   - Start local server: `npx serve .` or `python3 -m http.server`
   - Open test-matcher.html in browser
   - Paste sample script
   - Type words and verify matching works
</verification>

<success_criteria>
- fuse.js and stopword npm packages installed
- matching/textUtils.js exports normalization and filtering functions
- matching/TextMatcher.js exports TextMatcher class
- TextMatcher uses sliding window pattern with consecutive match confirmation
- Test page allows manual verification of matching logic
</success_criteria>

<output>
After completion, create `.planning/phases/03-basic-text-matching/03-01-SUMMARY.md`
</output>
