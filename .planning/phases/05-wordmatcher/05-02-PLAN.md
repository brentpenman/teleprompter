---
phase: 05-wordmatcher
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - matching/WordMatcher.js
  - matching/WordMatcher.test.js
autonomous: true

must_haves:
  truths:
    - "WordMatcher handles edge cases gracefully (empty input, no matches)"
    - "Character offsets are tracked for highlighting integration"
    - "TypeScript-style JSDoc provides IDE support"
  artifacts:
    - path: "matching/WordMatcher.js"
      provides: "Production-ready stateless matcher"
      exports: ["createMatcher", "findMatches"]
      contains: "@typedef"
    - path: "matching/WordMatcher.test.js"
      provides: "Edge case coverage"
      min_tests: 10
  key_links:
    - from: "matching/WordMatcher.js"
      to: "Phase 6 PositionTracker"
      via: "API contract: findMatches returns {candidates, bestMatch}"
      pattern: "return.*candidates.*bestMatch"
---

<objective>
Harden WordMatcher with edge case handling, character offset tracking for highlighting, and JSDoc type definitions.

Purpose: Make WordMatcher production-ready for integration with PositionTracker (Phase 6) and Highlighter (existing). The character offsets enable smooth handoff to the existing CSS Custom Highlight API.

Output: Robust WordMatcher.js with comprehensive edge case coverage and clear type contracts.
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-wordmatcher/05-01-SUMMARY.md
@matching/WordMatcher.js
@matching/Highlighter.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edge case tests and handling</name>
  <files>matching/WordMatcher.test.js, matching/WordMatcher.js</files>
  <action>
    Add test cases for edge conditions:
    1. Empty transcript -> returns { candidates: [], bestMatch: null }
    2. Transcript with only filler words -> returns { candidates: [], bestMatch: null }
    3. Script shorter than windowSize -> still works (uses available words)
    4. currentPosition at script end -> searches backward within radius
    5. currentPosition negative -> clamps to 0
    6. currentPosition beyond script length -> clamps to script length

    Update findMatches to handle these gracefully:
    - Early return for empty/short input (already done)
    - Clamp searchStart to >= 0
    - Clamp searchEnd to <= scriptIndex.length
    - Handle edge case where window > remaining script words
  </action>
  <verify>npm test -- --testPathPattern=WordMatcher (all tests pass including new edge cases)</verify>
  <done>Edge case tests added and passing; function handles all boundary conditions without throwing</done>
</task>

<task type="auto">
  <name>Task 2: Add character offset tracking for highlighting</name>
  <files>matching/WordMatcher.js</files>
  <action>
    Modify createMatcher to track character offsets:

    ```javascript
    export function createMatcher(scriptText, options = {}) {
      // ... existing code ...

      // Track character offsets for highlighting
      let charOffset = 0;
      const scriptIndex = [];

      for (let i = 0; i < scriptWords.length; i++) {
        const word = scriptWords[i];
        // Find word in original text (preserving case for offset)
        const foundIndex = scriptText.toLowerCase().indexOf(word, charOffset);
        const startOffset = foundIndex >= 0 ? foundIndex : charOffset;
        const endOffset = startOffset + word.length;

        scriptIndex.push({
          word,
          index: i,
          startOffset,
          endOffset
        });

        charOffset = endOffset;
      }

      // ... rest of function
    }
    ```

    Update findMatches return to include offsets in candidates:
    ```javascript
    candidates.push({
      position: endPosition,
      startPosition: pos,
      matchCount,
      avgFuseScore,
      distance,
      combinedScore,
      // Add character offsets for highlighting
      startOffset: scriptIndex[pos].startOffset,
      endOffset: scriptIndex[endPosition].endOffset
    });
    ```

    This enables Phase 6/7 to highlight matched text using CSS Custom Highlight API.
  </action>
  <verify>
    ```bash
    node -e "
      import('./matching/WordMatcher.js').then(({ createMatcher, findMatches }) => {
        const m = createMatcher('four score and seven');
        const r = findMatches('score and', m, 0);
        console.log('Has offsets:', r.bestMatch?.startOffset !== undefined);
      });
    "
    ```
  </verify>
  <done>createMatcher includes startOffset/endOffset in scriptIndex; findMatches returns these in candidates</done>
</task>

<task type="auto">
  <name>Task 3: Add JSDoc type definitions</name>
  <files>matching/WordMatcher.js</files>
  <action>
    Add comprehensive JSDoc at top of file:

    ```javascript
    /**
     * @typedef {Object} WordEntry
     * @property {string} word - Normalized word
     * @property {number} index - Position in script
     * @property {number} startOffset - Character offset start
     * @property {number} endOffset - Character offset end
     */

    /**
     * @typedef {Object} Matcher
     * @property {WordEntry[]} scriptIndex - Indexed script words
     * @property {import('fuse.js').default} fuse - Fuse.js instance
     * @property {string[]} scriptWords - Array of normalized words
     */

    /**
     * @typedef {Object} MatchCandidate
     * @property {number} position - End word index of match
     * @property {number} startPosition - Start word index of match
     * @property {number} matchCount - Number of words matched
     * @property {number} avgFuseScore - Average Fuse.js score (0=perfect, 1=mismatch)
     * @property {number} distance - Word distance from currentPosition
     * @property {number} combinedScore - Final score (higher=better, 0-1 range)
     * @property {number} startOffset - Character offset for highlighting
     * @property {number} endOffset - Character offset for highlighting
     */

    /**
     * @typedef {Object} MatchResult
     * @property {MatchCandidate[]} candidates - All candidates sorted by score
     * @property {MatchCandidate|null} bestMatch - Highest scoring candidate
     */

    /**
     * @typedef {Object} MatchOptions
     * @property {number} [radius=50] - Search radius around currentPosition
     * @property {number} [minConsecutive=2] - Minimum consecutive words required
     * @property {number} [windowSize=3] - Words to take from transcript end
     * @property {number} [distanceWeight=0.3] - How much distance affects score (0-1)
     * @property {number} [threshold=0.3] - Fuse.js fuzzy threshold
     */
    ```

    Update function signatures with JSDoc:
    ```javascript
    /**
     * Build matcher from script text (call once when script changes)
     * @param {string} scriptText - Full script text
     * @param {{ threshold?: number }} [options] - Configuration
     * @returns {Matcher}
     */
    export function createMatcher(scriptText, options = {}) { ... }

    /**
     * Find matches for spoken transcript (pure function)
     * @param {string} transcript - Spoken words from speech recognition
     * @param {Matcher} matcher - Result from createMatcher
     * @param {number} currentPosition - Current word position
     * @param {MatchOptions} [options] - Search configuration
     * @returns {MatchResult}
     */
    export function findMatches(transcript, matcher, currentPosition, options = {}) { ... }
    ```
  </action>
  <verify>
    ```bash
    # Check JSDoc is present
    grep -c "@typedef" matching/WordMatcher.js  # Should be >= 5
    grep -c "@param" matching/WordMatcher.js    # Should be >= 6
    grep -c "@returns" matching/WordMatcher.js  # Should be >= 2
    ```
  </verify>
  <done>JSDoc type definitions added; IDE shows type hints for createMatcher, findMatches, and all options</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
npm test -- --testPathPattern=WordMatcher

# Verify exports and types
node -e "
  import('./matching/WordMatcher.js').then(({ createMatcher, findMatches }) => {
    // Test basic flow
    const m = createMatcher('the quick brown fox jumps over');
    const r = findMatches('quick brown', m, 0);
    console.log('bestMatch:', r.bestMatch);
    console.log('has offsets:', r.bestMatch?.startOffset !== undefined);
    console.log('candidates count:', r.candidates.length);
  });
"

# Verify no state leakage (same inputs = same outputs)
node -e "
  import('./matching/WordMatcher.js').then(({ createMatcher, findMatches }) => {
    const m = createMatcher('test words here');
    const r1 = findMatches('test words', m, 0);
    const r2 = findMatches('test words', m, 0);
    console.log('Deterministic:', r1.bestMatch?.position === r2.bestMatch?.position);
  });
"
```
</verification>

<success_criteria>
- [ ] 10+ tests passing (6 core + 4+ edge cases)
- [ ] Edge cases handled without throwing
- [ ] Character offsets in scriptIndex and candidate results
- [ ] JSDoc typedefs for all data structures
- [ ] JSDoc params/returns on both exported functions
- [ ] Function remains pure (same inputs = same outputs)
</success_criteria>

<output>
After completion, create `.planning/phases/05-wordmatcher/05-02-SUMMARY.md`
</output>
