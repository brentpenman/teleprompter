---
phase: 05-wordmatcher
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - matching/WordMatcher.js
  - matching/WordMatcher.test.js
autonomous: true

must_haves:
  truths:
    - "findMatches returns candidates scored by combined fuzzy+distance score"
    - "Nearby matches rank higher than distant matches of equal fuzzy quality"
    - "Search is constrained to radius around currentPosition"
    - "Minimum 2 consecutive words required for a match"
  artifacts:
    - path: "matching/WordMatcher.js"
      provides: "Stateless matching functions"
      exports: ["createMatcher", "findMatches"]
    - path: "matching/WordMatcher.test.js"
      provides: "Test coverage for matching behavior"
      min_tests: 6
  key_links:
    - from: "matching/WordMatcher.js"
      to: "fuse.js"
      via: "import Fuse from 'fuse.js'"
      pattern: "import Fuse"
    - from: "matching/WordMatcher.js"
      to: "matching/textUtils.js"
      via: "import { tokenize, filterFillerWords }"
      pattern: "import.*textUtils"
---

<objective>
Implement WordMatcher as a stateless pure function that scores match candidates by both fuzzy match quality and positional proximity using TDD.

Purpose: This is the foundation of the v1.1 rewrite. WordMatcher replaces the stateful TextMatcher with a clean, testable pure function. Position awareness becomes intrinsic to scoring rather than an afterthought.

Output: Working WordMatcher.js with comprehensive tests proving it meets MATCH-01 through MATCH-04 and ARCH-01.
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-wordmatcher/05-RESEARCH.md
@matching/textUtils.js
</context>

<feature>
  <name>WordMatcher - Stateless Fuzzy Matching with Distance Weighting</name>
  <files>matching/WordMatcher.js, matching/WordMatcher.test.js</files>
  <behavior>
    WordMatcher exports two functions:

    1. createMatcher(scriptText, options?) -> { scriptIndex, fuse, scriptWords }
       - Tokenizes script text
       - Builds Fuse.js index with ignoreLocation: true
       - Returns reusable matcher object

    2. findMatches(transcript, matcher, currentPosition, options?) -> { candidates, bestMatch }
       - Pure function - no side effects, no state
       - Takes spoken transcript string
       - Tokenizes and filters filler words
       - Searches within radius of currentPosition
       - Requires minConsecutive (default 2) consecutive words to match
       - Scores using: combinedScore = matchQuality * (1 - distanceWeight * distancePenalty)
       - Returns sorted candidates array and bestMatch (or null)

    Test cases (input -> expected output):

    1. Exact match near position:
       - Script: "four score and seven years ago"
       - Transcript: "score and seven"
       - currentPosition: 1
       - Expected: bestMatch.position = 3 (index of "seven"), combinedScore > 0.9

    2. Prefer nearby over distant:
       - Script: "hello world ... [50 words] ... hello world"
       - Transcript: "hello world"
       - currentPosition: 5
       - Expected: bestMatch is first "hello world" (position ~1), not distant one

    3. Radius constraint:
       - Script: "start ... [100 words] ... target phrase"
       - Transcript: "target phrase"
       - currentPosition: 0, radius: 10
       - Expected: bestMatch = null (outside radius)

    4. Minimum consecutive words:
       - Script: "the quick brown fox"
       - Transcript: "brown"  (single word)
       - Expected: bestMatch = null (below minConsecutive)

    5. Fuzzy matching works:
       - Script: "going to the store"
       - Transcript: "gonna the store" (paraphrase)
       - Expected: bestMatch found with reasonable score

    6. Distance penalty applied:
       - Script: "test words here"
       - Two matches at distance 0 and distance 40
       - Expected: distance 0 has higher combinedScore
  </behavior>
  <implementation>
    RED Phase:
    1. Create matching/WordMatcher.test.js with 6 test cases above
    2. Import from ./WordMatcher.js (doesn't exist yet)
    3. Run tests - they MUST fail
    4. Commit: test(05-01): add failing tests for WordMatcher

    GREEN Phase:
    1. Create matching/WordMatcher.js
    2. Implement createMatcher:
       - import Fuse from 'fuse.js'
       - import { tokenize, filterFillerWords } from './textUtils.js'
       - Build scriptIndex array: [{ word, index }, ...]
       - Create Fuse instance with keys: ['word'], threshold, includeScore, ignoreLocation: true
       - Return { scriptIndex, fuse, scriptWords }
    3. Implement findMatches:
       - Destructure options: radius=50, minConsecutive=2, windowSize=3, distanceWeight=0.3, threshold=0.3
       - Tokenize and filter transcript
       - Return early if filtered.length < minConsecutive
       - Take last windowSize words as search window
       - Calculate searchStart/searchEnd from currentPosition +/- radius
       - Iterate positions, checking consecutive matches
       - For each full match: calculate combinedScore = (1 - avgFuseScore) * (1 - distanceWeight * distancePenalty)
       - Sort by combinedScore descending
       - Return { candidates, bestMatch: candidates[0] || null }
    4. Run tests - they MUST pass
    5. Commit: feat(05-01): implement WordMatcher stateless matching

    REFACTOR Phase (if needed):
    1. Clean up any obvious code smells
    2. Ensure no state is retained between calls
    3. Run tests - MUST still pass
    4. Commit if changes: refactor(05-01): clean up WordMatcher
  </implementation>
</feature>

<verification>
```bash
# Run tests
npm test -- --testPathPattern=WordMatcher

# Verify exports
node -e "import('./matching/WordMatcher.js').then(m => console.log('Exports:', Object.keys(m)))"

# Verify stateless (no 'this' references except in Fuse callback)
grep -c "this\." matching/WordMatcher.js  # Should be 0 or minimal
```
</verification>

<success_criteria>
- [ ] All 6+ test cases pass
- [ ] createMatcher returns { scriptIndex, fuse, scriptWords }
- [ ] findMatches is pure (same inputs always produce same outputs)
- [ ] Distance weighting demonstrably affects rankings
- [ ] Radius constraint is enforced
- [ ] Minimum consecutive match requirement works
- [ ] No state stored in module-level variables
</success_criteria>

<output>
After completion, create `.planning/phases/05-wordmatcher/05-01-SUMMARY.md`
</output>
