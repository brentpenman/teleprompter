---
phase: 09-model-loading-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/model/ModelCache.js
  - src/model/StorageQuota.js
autonomous: true

must_haves:
  truths:
    - "App can store 40MB binary model in IndexedDB"
    - "App can retrieve cached model instantly (<2s)"
    - "App checks available storage quota before operations"
    - "App handles QuotaExceededError with clear error message"
  artifacts:
    - path: "src/model/ModelCache.js"
      provides: "IndexedDB wrapper for binary model storage"
      exports: ["ModelCache"]
      min_lines: 80
    - path: "src/model/StorageQuota.js"
      provides: "Storage quota checking and management"
      exports: ["checkStorageQuota"]
      min_lines: 30
  key_links:
    - from: "src/model/ModelCache.js"
      to: "IndexedDB API"
      via: "indexedDB.open transaction"
      pattern: "indexedDB\\.open"
    - from: "src/model/StorageQuota.js"
      to: "StorageManager API"
      via: "navigator.storage.estimate()"
      pattern: "navigator\\.storage\\.estimate"
---

<objective>
Create storage infrastructure for caching large binary models using IndexedDB with quota management and error handling.

Purpose: Model downloads are 40MB and expensive on mobile data. IndexedDB provides reliable offline storage with sufficient capacity. Storage quota checking prevents download failures and provides actionable errors to users.

Output: ModelCache class for IndexedDB operations and checkStorageQuota utility for quota management
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-model-loading-infrastructure/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create IndexedDB model cache</name>
  <files>src/model/ModelCache.js</files>
  <action>
Create a ModelCache class that wraps IndexedDB operations for storing and retrieving 40MB binary models.

Implementation from research (Pattern 2: IndexedDB Binary Storage):

Class structure:
- constructor(dbName = 'vosk-models', version = 1)
- async open() - Initialize database with upgrade handler
- async saveModel(id, name, version, hash, arrayBuffer) - Store model
- async getModel(id) - Retrieve model by ID
- async deleteModel(id) - Delete model
- async listModels() - List all cached model IDs

Database schema:
- Object store: 'models' with keyPath 'id'
- Indexes: 'name', 'version' (NOT 'data' - never index binary data)
- Model object: { id, name, version, hash, data: ArrayBuffer, timestamp }

Critical requirements:
- Do NOT index the 'data' field (40MB binary) - this causes severe performance degradation
- Wrap IndexedDB writes in try-catch for QuotaExceededError
- Provide user-actionable error messages when quota exceeded
- Use promises to wrap IndexedDB event handlers

Error handling:
- QuotaExceededError -> "Storage quota exceeded. Please free up space."
- Generic errors -> propagate with context

The class should use native IndexedDB (no wrapper library - research confirmed native is sufficient for this use case).
  </action>
  <verify>
Create directory and test basic operations:

```bash
mkdir -p src/model
```

After implementing, test in browser console:
```javascript
import { ModelCache } from './src/model/ModelCache.js';
const cache = new ModelCache();
await cache.open();

// Test with small binary
const testData = new Uint8Array([1, 2, 3, 4, 5]).buffer;
await cache.saveModel('test-id', 'test-model', 'v1.0', 'abc123', testData);
const retrieved = await cache.getModel('test-id');
console.log('Retrieved:', retrieved);

const models = await cache.listModels();
console.log('Models:', models);

await cache.deleteModel('test-id');
```

Expected: All operations complete without errors. Retrieved model matches saved model.
  </verify>
  <done>
ModelCache class exists and provides open, saveModel, getModel, deleteModel, listModels methods. Class stores binary data in IndexedDB without indexing it. QuotaExceededError is caught and provides clear error message. Basic test operations succeed in browser console.
  </done>
</task>

<task type="auto">
  <name>Create storage quota checker</name>
  <files>src/model/StorageQuota.js</files>
  <action>
Create a utility function that checks available storage quota before large downloads using the StorageManager API.

Implementation from research (Pattern 4: Storage Quota Management):

Export checkStorageQuota(requiredBytes) function that:
- Calls navigator.storage.estimate() to get quota and usage
- Calculates available space: quota - usage
- Adds 10% safety buffer to required bytes (research notes imprecise compression)
- Returns object: { hasSpace, available, required, percentUsed, quota, usage, warning? }

Fallback handling:
- If navigator.storage.estimate not available (old browsers), return { hasSpace: true, warning: 'Cannot verify storage quota on this browser' }
- This optimistic fallback allows downloads to proceed on browsers without StorageManager API

Return object format:
```javascript
{
  hasSpace: boolean,           // available >= required * 1.1
  available: number,           // bytes available
  required: number,            // bytes requested
  percentUsed: number,         // Math.round((usage / quota) * 100)
  quota: number,               // total quota in bytes
  usage: number,               // current usage in bytes
  warning?: string             // optional warning message
}
```

Consumer can check hasSpace and display percentUsed to user.
  </action>
  <verify>
Test the quota checker in browser console:

```javascript
import { checkStorageQuota } from './src/model/StorageQuota.js';

// Test with 40MB model size
const MODEL_SIZE = 40 * 1024 * 1024;
const result = await checkStorageQuota(MODEL_SIZE);
console.log('Quota check:', result);
console.log(`Has space: ${result.hasSpace}`);
console.log(`Available: ${(result.available / 1024 / 1024).toFixed(1)}MB`);
console.log(`Required: ${(result.required / 1024 / 1024).toFixed(1)}MB`);
console.log(`Usage: ${result.percentUsed}%`);
```

Expected: Function returns quota information with hasSpace property. Available space should be > 44MB (40MB + 10% buffer) for hasSpace to be true.
  </verify>
  <done>
checkStorageQuota function exists and uses StorageManager API to calculate available storage. Function adds 10% safety buffer to required bytes. Returns comprehensive object with hasSpace, available, quota, usage, percentUsed. Fallback handles browsers without StorageManager API gracefully.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. ModelCache can store and retrieve binary data in IndexedDB
2. checkStorageQuota correctly calculates available storage
3. Both modules handle edge cases (quota exceeded, old browsers)
4. No dependencies on external libraries (native browser APIs only)
5. Error messages are user-actionable
</verification>

<success_criteria>
- ModelCache.js exists with open, saveModel, getModel, deleteModel, listModels methods
- ModelCache does NOT index binary 'data' field
- ModelCache catches QuotaExceededError and provides clear error message
- StorageQuota.js exports checkStorageQuota function
- checkStorageQuota uses navigator.storage.estimate() with 10% safety buffer
- Both modules tested successfully in browser console with sample data
- No external dependencies added (uses native browser APIs)
</success_criteria>

<output>
After completion, create `.planning/phases/09-model-loading-infrastructure/09-02-SUMMARY.md`
</output>
