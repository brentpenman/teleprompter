---
phase: 09-model-loading-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["09-02", "09-03"]
files_modified:
  - src/model/ModelLoader.js
autonomous: false

must_haves:
  truths:
    - "App loads model from cache on subsequent visits (<2s)"
    - "App downloads model if not cached, showing progress"
    - "App validates model hash before caching"
    - "App checks quota before downloading"
    - "App handles all error cases with clear messages"
  artifacts:
    - path: "src/model/ModelLoader.js"
      provides: "Orchestrator for model loading (cache -> download -> validate -> cache)"
      exports: ["ModelLoader"]
      min_lines: 80
  key_links:
    - from: "src/model/ModelLoader.js"
      to: "src/model/ModelCache.js"
      via: "cache.getModel/saveModel"
      pattern: "cache\\.(getModel|saveModel)"
    - from: "src/model/ModelLoader.js"
      to: "src/model/ModelDownloader.js"
      via: "downloader.download"
      pattern: "downloader\\.download"
    - from: "src/model/ModelLoader.js"
      to: "src/model/ModelValidator.js"
      via: "validator.validate"
      pattern: "validator\\.validate"
    - from: "src/model/ModelLoader.js"
      to: "src/model/StorageQuota.js"
      via: "checkStorageQuota"
      pattern: "checkStorageQuota"
---

<objective>
Create orchestration layer that coordinates caching, downloading, and validation to provide reliable model loading with comprehensive error handling.

Purpose: ModelLoader is the high-level API that consumers will use. It abstracts away the complexity of cache checks, downloads, validation, and quota management, providing a simple async loadModel() interface with progress callbacks.

Output: ModelLoader class that orchestrates all model loading operations and end-to-end verification of the complete system
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-model-loading-infrastructure/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create ModelLoader orchestrator</name>
  <files>src/model/ModelLoader.js</files>
  <action>
Create a ModelLoader class that orchestrates the complete model loading workflow: check cache -> check quota -> download -> validate -> cache -> return model.

Implementation from research (Pattern 6: Complete Model Loader Orchestration):

Class structure:
- constructor(cache, downloader, validator) - Dependency injection
- async loadModel(modelConfig, onProgress) - Main loading logic
- async clearCache() - Helper to clear all cached models

Loading workflow:
1. Check if model exists in cache AND hash matches
   - If yes: return cached ArrayBuffer immediately
   - Call onProgress({ status: 'cached', loaded: 100, total: 100 })

2. Check storage quota before downloading
   - Call checkStorageQuota(modelConfig.size)
   - If insufficient: throw error with MB available/required

3. Download model
   - Call downloader.download(url, progressCallback)
   - Forward progress to onProgress({ status: 'downloading', loaded, total, percentage })

4. Validate hash
   - Call onProgress({ status: 'validating' })
   - Call validator.validate(arrayBuffer, modelConfig.hash)
   - If invalid: throw error "Model validation failed: hash mismatch"

5. Cache model
   - Call onProgress({ status: 'caching' })
   - Try cache.saveModel() with try-catch
   - If QuotaExceededError: warn but don't fail (model downloaded and validated)
   - Other errors: propagate

6. Return model
   - Call onProgress({ status: 'complete' })
   - Return ArrayBuffer

Progress status values: 'cached', 'checking-quota', 'downloading', 'validating', 'caching', 'complete'

Error handling:
- Quota errors: Include MB available/required in message
- Network errors: Propagate with context
- Validation errors: Clear message about hash mismatch
- Cache errors: Warn but don't fail if model already downloaded

Import dependencies:
```javascript
import { ModelCache } from './ModelCache.js';
import { ModelDownloader } from './ModelDownloader.js';
import { ModelValidator } from './ModelValidator.js';
import { checkStorageQuota } from './StorageQuota.js';
```

The clearCache() helper should iterate through all models and delete them - useful for debugging and testing.
  </action>
  <verify>
Test ModelLoader with small file first (to avoid long downloads):

```javascript
import { ModelLoader } from './src/model/ModelLoader.js';
import { ModelCache } from './src/model/ModelCache.js';
import { ModelDownloader } from './src/model/ModelDownloader.js';
import { ModelValidator } from './src/model/ModelValidator.js';

const cache = new ModelCache();
await cache.open();

const downloader = new ModelDownloader();
const validator = new ModelValidator();
const loader = new ModelLoader(cache, downloader, validator);

// Test with small file (fuse.js minified)
const testConfig = {
  id: 'test-model',
  name: 'Test Model',
  version: '1.0',
  url: 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.min.js',
  size: 50000,  // ~50KB
  hash: ''  // Will fail validation, but tests workflow
};

const model = await loader.loadModel(testConfig, (progress) => {
  console.log('Progress:', progress);
});

console.log('Loaded model:', model.byteLength, 'bytes');

// Test cache hit on second load
const cached = await loader.loadModel(testConfig, (progress) => {
  console.log('Cached progress:', progress);
});

console.log('Cache worked:', cached.byteLength === model.byteLength);
```

Expected: First load downloads with progress updates (downloading, validating, caching). Validation fails due to empty hash but workflow completes. Second load returns immediately with 'cached' status.
  </verify>
  <done>
ModelLoader class exists with loadModel(modelConfig, onProgress) and clearCache() methods. Orchestrates cache check, quota check, download, validation, and caching in correct order. Handles all error cases with clear messages. Progress callback fires with appropriate status values. Cache hits return immediately without re-downloading.
  </done>
</task>

<task type="checkpoint:human-verify">
  <what-built>
Complete model loading infrastructure with:
- COOP/COEP headers for cross-origin isolation (Plan 01)
- IndexedDB caching and quota management (Plan 02)
- Progress-tracked downloading and SHA-256 validation (Plan 03)
- High-level ModelLoader orchestrator (Plan 04)
  </what-built>
  <how-to-verify>
1. Start HTTPS server:
   ```bash
   npm start
   ```

2. Open https://localhost:3000 in browser

3. Open DevTools console

4. Verify cross-origin isolation:
   ```javascript
   console.log('Cross-origin isolated:', self.crossOriginIsolated);
   console.log('SharedArrayBuffer available:', typeof SharedArrayBuffer);
   ```
   Expected: Both should be true/function

5. Test complete model loading workflow:
   ```javascript
   import { ModelLoader } from './src/model/ModelLoader.js';
   import { ModelCache } from './src/model/ModelCache.js';
   import { ModelDownloader } from './src/model/ModelDownloader.js';
   import { ModelValidator } from './src/model/ModelValidator.js';
   import { modelConfig } from './src/config/modelConfig.js';

   const cache = new ModelCache();
   await cache.open();

   const loader = new ModelLoader(cache, new ModelDownloader(), new ModelValidator());

   // Note: This will attempt to download the actual Vosk model (~40MB)
   // First verify the URL is accessible and has CORS headers
   console.log('Attempting to load model from:', modelConfig.url);

   const model = await loader.loadModel(modelConfig, (progress) => {
     console.log(`Status: ${progress.status}`, progress.percentage ? `${progress.percentage}%` : '');
   });

   console.log('Model loaded successfully:', model.byteLength, 'bytes');
   ```

6. Test cache on second load:
   ```javascript
   const cached = await loader.loadModel(modelConfig, (progress) => {
     console.log('Cache check:', progress);
   });
   console.log('Loaded from cache:', cached.byteLength === model.byteLength);
   ```
   Expected: Second load returns immediately with 'cached' status

7. Verify error handling:
   - Check DevTools Network tab for COOP/COEP headers on all resources
   - Verify progress updates during download
   - Check IndexedDB in DevTools Application tab shows 'vosk-models' database
   - Verify model hash validation (may need to update hash in modelConfig.js after first download)

**Expected behaviors:**
- Cross-origin isolation enabled (self.crossOriginIsolated === true)
- Model downloads with progress updates (percentage increases from 0-100)
- Model validates successfully (or fails with clear hash mismatch message if hash not updated)
- Model caches in IndexedDB
- Second load retrieves from cache instantly (<2s)
- All error messages are clear and actionable

**Known issues to watch for:**
- If model URL has CORS issues, download will fail - may need to find alternative CDN
- If hash is still empty in modelConfig.js, validation will fail - update with actual hash
- If Safari, quota limits may be tighter - verify storage check works
  </how-to-verify>
  <resume-signal>
Type "approved" if all verifications pass, or describe any issues encountered for troubleshooting.
  </resume-signal>
</task>

</tasks>

<verification>
After completing orchestrator and verification:

1. ModelLoader orchestrates all components correctly
2. Cache hits avoid re-downloading
3. Progress callbacks fire with appropriate status values
4. Error handling provides clear, actionable messages
5. Cross-origin isolation works (SharedArrayBuffer available)
6. Complete workflow tested end-to-end
7. All requirements MODEL-01 through MODEL-08 satisfied
</verification>

<success_criteria>
- ModelLoader.js exists and exports ModelLoader class
- loadModel() method orchestrates cache -> quota -> download -> validate -> cache workflow
- Progress callback fires with status values: cached, checking-quota, downloading, validating, caching, complete
- clearCache() helper deletes all cached models
- Dependency injection used for cache, downloader, validator (testable)
- Human verification confirms end-to-end workflow works
- Cross-origin isolation verified (self.crossOriginIsolated === true)
- 40MB model downloads with progress, validates, caches, and retrieves successfully
- Second load returns cached model instantly
</success_criteria>

<output>
After completion, create `.planning/phases/09-model-loading-infrastructure/09-04-SUMMARY.md`
</output>
