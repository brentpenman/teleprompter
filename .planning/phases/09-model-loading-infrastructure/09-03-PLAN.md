---
phase: 09-model-loading-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/model/ModelDownloader.js
  - src/model/ModelValidator.js
  - src/config/modelConfig.js
autonomous: true

must_haves:
  truths:
    - "App downloads 40MB model with visible progress (percentage and MB)"
    - "App validates model integrity using SHA-256 hash"
    - "App rejects corrupted models before caching"
    - "App handles network failures gracefully"
  artifacts:
    - path: "src/model/ModelDownloader.js"
      provides: "Fetch-based model downloader with progress tracking"
      exports: ["ModelDownloader"]
      min_lines: 50
    - path: "src/model/ModelValidator.js"
      provides: "SHA-256 hash validator for model integrity"
      exports: ["ModelValidator"]
      min_lines: 30
    - path: "src/config/modelConfig.js"
      provides: "Model metadata (URL, hash, size, version)"
      exports: ["modelConfig"]
      min_lines: 15
  key_links:
    - from: "src/model/ModelDownloader.js"
      to: "fetch ReadableStream"
      via: "response.body.getReader()"
      pattern: "response\\.body\\.getReader"
    - from: "src/model/ModelValidator.js"
      to: "Web Crypto API"
      via: "crypto.subtle.digest"
      pattern: "crypto\\.subtle\\.digest"
---

<objective>
Create download infrastructure for fetching large models with progress tracking and integrity validation using native browser APIs.

Purpose: Users need to see download progress for 40MB files. SHA-256 validation prevents corrupted models from being cached. Network failures must be handled gracefully with clear error messages.

Output: ModelDownloader with progress callbacks, ModelValidator using Web Crypto API, and model configuration metadata
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-model-loading-infrastructure/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create model downloader with progress tracking</name>
  <files>src/model/ModelDownloader.js</files>
  <action>
Create a ModelDownloader class that downloads large files using Fetch API with real-time progress tracking.

Implementation from research (Pattern 1: Download with Progress Tracking):

Class structure:
- constructor()
- async download(url, onProgress) - Download file with progress callback

Download implementation:
- Use fetch() to initiate request
- Check response.ok (throw error if not 200-299)
- Read Content-Length header (required for progress percentage)
- Throw error if Content-Length missing: "Content-Length header missing"
- Use response.body.getReader() to stream chunks
- Accumulate chunks in array, track loaded bytes
- Call onProgress({ loaded, total, percentage }) on each chunk
- Concatenate chunks into single Uint8Array
- Return ArrayBuffer

Progress callback format:
```javascript
onProgress({
  loaded: number,      // bytes downloaded so far
  total: number,       // total bytes from Content-Length
  percentage: number   // Math.round((loaded / total) * 100)
})
```

Error handling:
- Network errors -> propagate with context
- Missing Content-Length -> throw error (needed for progress)
- Non-OK response -> throw with status code

The downloader should NOT assume CORS is configured - consumer must ensure model URL has proper CORS headers.
  </action>
  <verify>
Test downloader with a small file (use fuse.js CDN as test):

```javascript
import { ModelDownloader } from './src/model/ModelDownloader.js';

const downloader = new ModelDownloader();

// Test with small CDN file
const url = 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.min.js';

const buffer = await downloader.download(url, (progress) => {
  console.log(`Progress: ${progress.percentage}% (${progress.loaded}/${progress.total})`);
});

console.log(`Downloaded ${buffer.byteLength} bytes`);
```

Expected: Progress callback fires multiple times with increasing percentages. Final buffer contains complete file.
  </verify>
  <done>
ModelDownloader class exists with download(url, onProgress) method. Download streams chunks via ReadableStream, tracks progress, calls onProgress callback with loaded/total/percentage. Returns ArrayBuffer on completion. Handles network errors and missing Content-Length header with clear error messages.
  </done>
</task>

<task type="auto">
  <name>Create SHA-256 model validator</name>
  <files>src/model/ModelValidator.js</files>
  <action>
Create a ModelValidator class that validates model integrity using SHA-256 hashing via Web Crypto API.

Implementation from research (Pattern 3: SHA-256 Validation):

Class structure:
- constructor()
- async validate(arrayBuffer, expectedHash) - Hash file and compare

Validation implementation:
- Hash entire ArrayBuffer using crypto.subtle.digest('SHA-256', arrayBuffer)
- Convert hash result to hex string using Uint8Array.toHex() (2025 method)
- Compare lowercase hex string to lowercase expectedHash
- Return boolean (true if match, false if mismatch)

Hash-to-hex conversion (use 2025 method):
```javascript
const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
const hashArray = new Uint8Array(hashBuffer);
const hashHex = hashArray.toHex();  // New in 2025!
```

Note: Web Crypto API does NOT support streaming. Must load entire file into memory for hashing. This is acceptable for 40MB models but keep in mind for future.

The validator should normalize both hashes to lowercase before comparison to handle different case conventions.
  </action>
  <verify>
Test validator with known hash:

```javascript
import { ModelValidator } from './src/model/ModelValidator.js';

const validator = new ModelValidator();

// Test with known string
const encoder = new TextEncoder();
const testData = encoder.encode('hello world');
const testBuffer = testData.buffer;

// SHA-256 of "hello world" is b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
const expectedHash = 'b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9';

const isValid = await validator.validate(testBuffer, expectedHash);
console.log('Validation result:', isValid);  // Should be true
```

Expected: Validation returns true for matching hash, false for mismatched hash.
  </verify>
  <done>
ModelValidator class exists with validate(arrayBuffer, expectedHash) method. Validator uses crypto.subtle.digest to hash ArrayBuffer, converts to hex using Uint8Array.toHex(), compares to expected hash (case-insensitive). Returns boolean indicating match. Test passes with known SHA-256 hash.
  </done>
</task>

<task type="auto">
  <name>Create model configuration</name>
  <files>src/config/modelConfig.js</files>
  <action>
Create a configuration file that defines model metadata (URL, expected hash, size, version).

Based on research, Vosk provides small English models (~40MB) suitable for browser use:

Model configuration object:
```javascript
export const modelConfig = {
  id: 'vosk-model-small-en-us-0.15',
  name: 'Vosk Small English US',
  version: '0.15',
  language: 'en-US',
  url: 'https://alphacephei.com/vosk/models/vosk-model-small-en-us-0.15.zip',
  size: 40 * 1024 * 1024,  // ~40MB (approximate)
  hash: '',  // TODO: Will need to download model and compute hash during execution
  description: 'Lightweight English model for browser-based recognition'
};
```

Note: The actual SHA-256 hash needs to be computed after downloading the model for the first time. For now, leave hash as empty string with TODO comment. The executor will download the model, compute the hash, and update this file.

Create directory first:
```bash
mkdir -p src/config
```

The URL points to Vosk's official CDN. Research noted potential CORS issues with some CDNs - this will need to be tested during execution.
  </action>
  <verify>
Verify configuration exports correctly:

```javascript
import { modelConfig } from './src/config/modelConfig.js';
console.log('Model config:', modelConfig);
console.log('Model URL:', modelConfig.url);
console.log('Model size:', (modelConfig.size / 1024 / 1024).toFixed(1), 'MB');
```

Expected: modelConfig object contains all required fields (id, name, version, language, url, size, hash, description).
  </verify>
  <done>
modelConfig.js exists and exports modelConfig object with id, name, version, language, url, size, hash (empty with TODO), and description. Configuration specifies Vosk small English model from official CDN. File imports successfully in browser.
  </done>
</task>

</tasks>

<verification>
After completing all three tasks:

1. ModelDownloader can fetch files with progress tracking
2. ModelValidator can verify SHA-256 hashes using Web Crypto API
3. modelConfig provides centralized model metadata
4. All modules use native browser APIs (no external dependencies)
5. Progress callbacks work correctly
6. Hash validation works with known test vectors
</verification>

<success_criteria>
- ModelDownloader.js exists with download(url, onProgress) method
- Downloader streams via ReadableStream and tracks progress
- Progress callback receives { loaded, total, percentage } on each chunk
- ModelValidator.js exists with validate(arrayBuffer, expectedHash) method
- Validator uses crypto.subtle.digest for SHA-256 hashing
- Validator converts hash to hex using Uint8Array.toHex()
- modelConfig.js exports modelConfig with URL, size, hash placeholder
- All three modules tested successfully in browser console
- No external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/09-model-loading-infrastructure/09-03-SUMMARY.md`
</output>
