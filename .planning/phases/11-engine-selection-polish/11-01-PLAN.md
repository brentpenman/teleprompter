---
phase: 11-engine-selection-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - settings/SettingsManager.js
  - settings/DeviceCapability.js
  - voice/recognizerFactory.js
autonomous: true

must_haves:
  truths:
    - "User preferences persist across sessions"
    - "App detects device capabilities and recommends appropriate engine"
    - "App creates correct recognizer based on preference with automatic fallback"
  artifacts:
    - path: "settings/SettingsManager.js"
      provides: "Settings persistence with localStorage error handling"
      exports: ["SettingsManager"]
      min_lines: 80
    - path: "settings/DeviceCapability.js"
      provides: "Device detection and engine recommendation"
      exports: ["DeviceCapability"]
      min_lines: 100
    - path: "voice/recognizerFactory.js"
      provides: "Recognizer creation with fallback logic"
      exports: ["RecognizerFactory"]
      min_lines: 100
  key_links:
    - from: "voice/recognizerFactory.js"
      to: "settings/DeviceCapability"
      via: "import for capability detection"
      pattern: "import.*DeviceCapability"
    - from: "voice/recognizerFactory.js"
      to: "voice/VoskRecognizer"
      via: "import for Vosk engine"
      pattern: "import.*VoskRecognizer"
    - from: "voice/recognizerFactory.js"
      to: "voice/SpeechRecognizer"
      via: "import for Web Speech API engine"
      pattern: "import.*SpeechRecognizer"
    - from: "voice/recognizerFactory.js"
      to: "model/ModelLoader"
      via: "import for model loading"
      pattern: "import.*ModelLoader"
---

<objective>
Create settings infrastructure for engine selection with localStorage persistence, device capability detection, and recognizer factory with automatic fallback.

Purpose: Enable users to select recognition engine (Vosk or Web Speech API) with intelligent defaults and graceful degradation when Vosk unavailable.

Output: Three foundational modules (SettingsManager, DeviceCapability, RecognizerFactory) that handle preferences, capability detection, and recognizer creation.
</objective>

<execution_context>
@/Users/brent/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brent/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-engine-selection-polish/11-RESEARCH.md
@.planning/phases/10-voskrecognizer-adapter/10-03-SUMMARY.md
@.planning/phases/09-model-loading-infrastructure/09-03-SUMMARY.md
@voice/SpeechRecognizer.js
@voice/VoskRecognizer.js
</context>

<tasks>

<task type="auto">
  <name>Create SettingsManager for localStorage persistence</name>
  <files>settings/SettingsManager.js</files>
  <action>
Create SettingsManager class following Pattern 1 from RESEARCH.md:
- Constructor accepts storageKey (default: 'teleprompter-settings')
- Defaults object: { recognitionEngine: 'auto', fontSize: 48, scrollSpeed: 50, highlightEnabled: true, mirrorEnabled: false }
- load() method: Reads localStorage with try-catch, returns merged defaults + stored settings
- save(settings) method: Writes to localStorage with try-catch, returns true/false for success
- set(key, value) method: Loads current, updates key, saves
- get(key) method: Loads current, returns value for key
- clear() method: Removes from localStorage with try-catch

Error handling critical:
- Wrap all localStorage access in try-catch (throws SecurityError in private browsing)
- Return defaults when localStorage.getItem() fails
- Return false when localStorage.setItem() fails (QuotaExceededError)
- Log warnings/errors to console but don't throw

Export as default: `export default SettingsManager;`
  </action>
  <verify>
Create test file settings/SettingsManager.test.js and run:
```bash
npm test settings/SettingsManager.test.js
```

Test cases:
- load() returns defaults when localStorage empty
- save() persists to localStorage
- set() updates specific key
- get() retrieves specific key
- Private browsing simulation (mock localStorage.setItem to throw)
  </verify>
  <done>
SettingsManager.js exists and exports SettingsManager class. Tests pass. localStorage access wrapped in try-catch. Handles private browsing gracefully.
  </done>
</task>

<task type="auto">
  <name>Create DeviceCapability for detection and recommendation</name>
  <files>settings/DeviceCapability.js</files>
  <action>
Create DeviceCapability class following Pattern 2 from RESEARCH.md:

**static detect() method:**
- Platform detection: isIOS, isAndroid, isMobile, isDesktop (from navigator.userAgent)
- SharedArrayBuffer availability: `typeof SharedArrayBuffer !== 'undefined' && self.crossOriginIsolated === true`
- Device memory: `navigator.deviceMemory || null` (Chromium only)
- Device tier: low (<2GB), mid (2-4GB), high (>4GB), unknown (if deviceMemory null)
- Web Speech API availability: `!!(window.SpeechRecognition || window.webkitSpeechRecognition)`
- Return object: { platform, capabilities, voskSupported, webSpeechSupported }

**static recommendEngine() method:**
- iOS → 'webspeech' (SharedArrayBuffer unavailable on iOS Safari)
- Android + voskSupported → 'vosk' (avoid notification beep - PRIMARY GOAL)
- Desktop + low memory → 'webspeech' (avoid large download)
- Desktop + voskSupported → 'vosk' (offline capability)
- Fallback → 'webspeech'
- Return: { engine, reason, shouldDownloadModel }

Export as default: `export default DeviceCapability;`

Use SpeechRecognizer.getPlatform() and VoskRecognizer.isSupported() where appropriate for consistency.
  </action>
  <verify>
Create test file settings/DeviceCapability.test.js and run:
```bash
npm test settings/DeviceCapability.test.js
```

Test cases:
- detect() returns correct platform flags
- detect() checks SharedArrayBuffer correctly
- recommendEngine() returns 'webspeech' for iOS (mock navigator.userAgent)
- recommendEngine() returns 'vosk' for Android with SharedArrayBuffer
- recommendEngine() returns 'webspeech' when Vosk unsupported
  </verify>
  <done>
DeviceCapability.js exists and exports DeviceCapability class. Tests pass. Recommendations match RESEARCH.md patterns. iOS always gets webspeech, Android gets vosk when supported.
  </done>
</task>

<task type="auto">
  <name>Create RecognizerFactory with fallback logic</name>
  <files>voice/recognizerFactory.js</files>
  <action>
Create RecognizerFactory class following Pattern 3 from RESEARCH.md:

**Imports:**
```javascript
import SpeechRecognizer from './SpeechRecognizer.js';
import VoskRecognizer from './VoskRecognizer.js';
import ModelLoader from '../model/ModelLoader.js';
import ModelCache from '../model/ModelCache.js';
import ModelDownloader from '../model/ModelDownloader.js';
import ModelValidator from '../model/ModelValidator.js';
import { modelConfig } from '../config/modelConfig.js';
import DeviceCapability from '../settings/DeviceCapability.js';
```

**static async create(preferredEngine, callbacks, onModelProgress) method:**
- Input: preferredEngine ('auto' | 'vosk' | 'webspeech'), callbacks { onTranscript, onError, onStateChange }, onModelProgress(progress)
- If preferredEngine === 'auto', call DeviceCapability.recommendEngine() to get targetEngine
- If targetEngine === 'vosk':
  - Check VoskRecognizer.isSupported(), if false → fall back to Web Speech API with reason
  - Try to create VoskRecognizer instance
  - Create ModelLoader (new ModelLoader(new ModelCache(), new ModelDownloader(), new ModelValidator()))
  - Load model: `await loader.loadModel(modelConfig, onModelProgress)`
  - Initialize Vosk: `await recognizer.loadModel(modelArrayBuffer)`
  - If any error → catch, log, fall back to Web Speech API with error message
  - Return: { recognizer, engineUsed: 'vosk', fallbackReason: null }
- If targetEngine === 'webspeech' or fallback:
  - Check SpeechRecognizer.isSupported(), if false → throw Error
  - Create SpeechRecognizer instance
  - Return: { recognizer, engineUsed: 'webspeech', fallbackReason }

**static _createWebSpeech(callbacks, fallbackReason) helper:**
- Private method for Web Speech API creation
- Returns: { recognizer, engineUsed: 'webspeech', fallbackReason }

Export as default: `export default RecognizerFactory;`

Error handling:
- Vosk initialization failures must not crash app - fall back to Web Speech API
- Log all fallback reasons to console.warn()
- Throw only if NEITHER engine is available
  </action>
  <verify>
Create test file voice/recognizerFactory.test.js and run:
```bash
npm test voice/recognizerFactory.test.js
```

Test cases:
- create('auto') uses DeviceCapability.recommendEngine()
- create('vosk') attempts Vosk, falls back to Web Speech on error
- create('webspeech') creates SpeechRecognizer directly
- Fallback reason included when falling back
- Throws error when neither engine supported (mock both isSupported to false)

Also manual verification:
```bash
node -e "import('./voice/recognizerFactory.js').then(m => console.log('Import successful'))"
```
  </verify>
  <done>
recognizerFactory.js exists and exports RecognizerFactory class. Tests pass. Automatic fallback works. Vosk errors caught and don't crash app. Web Speech API used when Vosk unavailable.
  </done>
</task>

</tasks>

<verification>
Run all tests:
```bash
npm test settings/ voice/recognizerFactory
```

Verify exports:
```bash
node -e "import('./settings/SettingsManager.js').then(m => console.log('SettingsManager:', m.default))"
node -e "import('./settings/DeviceCapability.js').then(m => console.log('DeviceCapability:', m.default))"
node -e "import('./voice/recognizerFactory.js').then(m => console.log('RecognizerFactory:', m.default))"
```

Verify localStorage handling in browser console:
- Open index.html in browser
- Run: `new SettingsManager().save({ test: true })`
- Verify no errors in console
- Run: `new SettingsManager().load()`
- Verify returns object with test: true
</verification>

<success_criteria>
- SettingsManager class exists with load/save/set/get/clear methods
- localStorage access wrapped in try-catch blocks
- DeviceCapability class exists with detect/recommendEngine static methods
- iOS devices get 'webspeech' recommendation (SharedArrayBuffer unavailable)
- Android devices with SharedArrayBuffer get 'vosk' recommendation
- RecognizerFactory class exists with create static method
- Factory attempts Vosk first, falls back to Web Speech API on error
- Factory uses DeviceCapability for 'auto' engine selection
- All three modules have passing tests
- No external dependencies added (uses existing Phase 9/10 infrastructure)
- Satisfies ENGINE-02 (localStorage persistence), ENGINE-03 (capability detection), INTEG-03 (fallback to Web Speech API), INTEG-04 (fallback on Vosk failure)
</success_criteria>

<output>
After completion, create `.planning/phases/11-engine-selection-polish/11-01-SUMMARY.md`
</output>
