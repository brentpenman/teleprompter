---
phase: 04-intelligent-scroll-control
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - matching/TextMatcher.js
  - matching/ScrollSync.js
autonomous: true

must_haves:
  truths:
    - "TextMatcher returns match confidence along with position"
    - "ScrollSync tracks state (CONFIDENT/UNCERTAIN/OFF_SCRIPT)"
    - "ScrollSync uses exponential easing for speed changes"
    - "ScrollSync detects and handles skips with confidence thresholds"
    - "Scroll never moves past the last matched position"
  artifacts:
    - path: "matching/TextMatcher.js"
      provides: "Position matching with confidence data"
      contains: "getMatchWithConfidence"
    - path: "matching/ScrollSync.js"
      provides: "State machine with exponential easing"
      contains: ["ScrollState", "CONFIDENT", "UNCERTAIN", "OFF_SCRIPT"]
  key_links:
    - from: "matching/TextMatcher.js"
      to: "Fuse.js includeScore"
      via: "search results"
      pattern: "r\\.score"
    - from: "matching/ScrollSync.js"
      to: "matching/ConfidenceLevel.js"
      via: "import"
      pattern: "import.*ConfidenceLevel"
    - from: "matching/ScrollSync.js"
      to: "exponential decay"
      via: "Math.exp"
      pattern: "Math\\.exp"
---

<objective>
Implement intelligent text matching with confidence and state-based scroll control

Purpose: Make TextMatcher return confidence data with matches, and make ScrollSync behave like a human operator - scrolling when confident, slowing when uncertain, pausing when off-script. Uses exponential easing for natural scroll dynamics and requires high confidence for skip detection.

Output: TextMatcher.js with getMatchWithConfidence(), ScrollSync.js with state machine, exponential easing, and skip detection
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-intelligent-scroll-control/04-CONTEXT.md
@.planning/phases/04-intelligent-scroll-control/04-RESEARCH.md
@matching/TextMatcher.js
@matching/ScrollSync.js
@matching/ConfidenceLevel.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add confidence scoring to TextMatcher</name>
  <files>matching/TextMatcher.js</files>
  <action>
Extend TextMatcher to return confidence data with matches:

1. **Import ConfidenceCalculator:**
   ```javascript
   import { ConfidenceCalculator } from './ConfidenceLevel.js';
   ```

2. **Initialize in constructor:**
   ```javascript
   this.confidenceCalculator = new ConfidenceCalculator();
   ```

3. **Add getMatchWithConfidence(transcript) method:**
   This is similar to matchTranscript but returns confidence data:
   ```javascript
   getMatchWithConfidence(transcript) {
     const words = tokenize(transcript);
     const filtered = filterFillerWords(words);

     if (filtered.length < this.minConsecutiveMatches) {
       return { position: null, confidence: null, level: 'low' };
     }

     const window = filtered.slice(-this.windowSize);

     // Search forward from current position first
     const result = this.searchRangeWithScore(this.currentPosition, this.scriptWords.length, window);
     if (result) {
       const matchEnd = result.startIndex + window.length - 1;
       if (matchEnd >= this.currentPosition) {
         this.currentPosition = matchEnd;
         this.lastMatchTime = Date.now();

         const msSinceLastMatch = 0; // Just matched now
         const rawConfidence = this.confidenceCalculator.calculate(
           result.avgScore, result.matchCount, window.length, msSinceLastMatch
         );

         return {
           position: matchEnd,
           confidence: rawConfidence,
           level: this.confidenceCalculator.toLevel(rawConfidence),
           matchCount: result.matchCount,
           windowSize: window.length
         };
       }
     }

     // Search backward for intentional skip-back
     const jumpThreshold = 10;
     const backResult = this.searchRangeWithScore(0, Math.max(0, this.currentPosition - jumpThreshold), window);
     if (backResult) {
       const matchEnd = backResult.startIndex + window.length - 1;
       this.currentPosition = matchEnd;
       this.lastMatchTime = Date.now();

       const rawConfidence = this.confidenceCalculator.calculate(
         backResult.avgScore, backResult.matchCount, window.length, 0
       );

       return {
         position: matchEnd,
         confidence: rawConfidence,
         level: this.confidenceCalculator.toLevel(rawConfidence),
         matchCount: backResult.matchCount,
         windowSize: window.length,
         isBackwardSkip: true
       };
     }

     // No match found - return low confidence based on time since last match
     const msSinceLastMatch = Date.now() - this.lastMatchTime;
     const rawConfidence = this.confidenceCalculator.calculate(1, 0, window.length, msSinceLastMatch);

     return {
       position: null,
       confidence: rawConfidence,
       level: this.confidenceCalculator.toLevel(rawConfidence)
     };
   }
   ```

4. **Add searchRangeWithScore(start, end, window) method:**
   Similar to searchRange but returns score data:
   ```javascript
   searchRangeWithScore(start, end, window) {
     for (let i = start; i < end - window.length + 1; i++) {
       let matchCount = 0;
       let totalScore = 0;

       for (let j = 0; j < window.length; j++) {
         const results = this.fuse.search(window[j]);
         const match = results.find(r => r.item.index === i + j && r.score <= this.threshold);

         if (match) {
           matchCount++;
           totalScore += match.score;
         }
       }

       if (matchCount >= this.minConsecutiveMatches) {
         return {
           startIndex: i,
           matchCount: matchCount,
           avgScore: matchCount > 0 ? totalScore / matchCount : 1
         };
       }
     }
     return null;
   }
   ```

Keep existing matchTranscript() method for backward compatibility - it can call getMatchWithConfidence internally and just return the position.
  </action>
  <verify>
In TextMatcher.js:
- Import statement for ConfidenceCalculator
- confidenceCalculator instance in constructor
- getMatchWithConfidence method exists and returns object with position, confidence, level
- searchRangeWithScore method exists and returns score data
  </verify>
  <done>
TextMatcher.getMatchWithConfidence() returns position with confidence level (high/medium/low) and raw confidence score
  </done>
</task>

<task type="auto">
  <name>Task 2: Add state machine and exponential easing to ScrollSync</name>
  <files>matching/ScrollSync.js</files>
  <action>
Major overhaul of ScrollSync to implement intelligent scroll behavior:

1. **Import ConfidenceCalculator:**
   ```javascript
   import { ConfidenceCalculator } from './ConfidenceLevel.js';
   ```

2. **Add ScrollState enum at top of file:**
   ```javascript
   export const ScrollState = {
     CONFIDENT: 'confident',
     UNCERTAIN: 'uncertain',
     OFF_SCRIPT: 'off_script'
   };
   ```

3. **Expand constructor with new properties:**
   ```javascript
   // State machine
   this.scrollState = ScrollState.CONFIDENT;
   this.uncertainStartTime = null;
   this.patientThreshold = options.patientThreshold || 4000; // 4 seconds before off-script

   // Easing time constants (ms)
   this.accelerationTimeConstant = 1500;
   this.decelerationTimeConstant = 500;
   this.resumeTimeConstant = 1000;

   // Skip detection
   this.shortSkipThreshold = 20;  // words - below this, smooth scroll
   this.longSkipThreshold = 100;  // words - above this, instant jump
   this.forwardSkipConfidence = 0.85;
   this.backwardSkipConfidence = 0.92;

   // Boundary tracking (never scroll past last matched position)
   this.lastMatchedPosition = 0; // word index of last confirmed match

   // Callbacks
   this.onStateChange = options.onStateChange || (() => {});
   this.onConfidenceChange = options.onConfidenceChange || (() => {});
   ```

4. **Add updateConfidence(matchResult) method:**
   Called when TextMatcher produces a result. Updates state machine:
   ```javascript
   updateConfidence(matchResult) {
     const now = Date.now();
     const prevState = this.scrollState;
     const level = matchResult.level; // 'high', 'medium', 'low'

     // Update last matched position if we have a match
     if (matchResult.position !== null) {
       this.lastMatchedPosition = Math.max(this.lastMatchedPosition, matchResult.position);
     }

     switch (this.scrollState) {
       case ScrollState.CONFIDENT:
         if (level === 'high') {
           // Stay confident - update position
           if (matchResult.position !== null) {
             this.handleMatch(matchResult);
           }
         } else {
           // Becoming uncertain
           this.scrollState = ScrollState.UNCERTAIN;
           this.uncertainStartTime = now;
         }
         break;

       case ScrollState.UNCERTAIN:
         if (level === 'high') {
           // Back to confident
           this.scrollState = ScrollState.CONFIDENT;
           this.uncertainStartTime = null;
           if (matchResult.position !== null) {
             this.handleMatch(matchResult);
           }
         } else {
           // Check patience threshold
           const duration = now - this.uncertainStartTime;
           if (duration > this.patientThreshold) {
             this.scrollState = ScrollState.OFF_SCRIPT;
           }
         }
         break;

       case ScrollState.OFF_SCRIPT:
         if (level === 'high' && matchResult.position !== null) {
           // Found position again
           this.scrollState = ScrollState.CONFIDENT;
           this.uncertainStartTime = null;
           this.handleMatch(matchResult);
         }
         break;
     }

     // Notify callbacks
     if (prevState !== this.scrollState) {
       this.onStateChange(this.scrollState, prevState);
     }
     this.onConfidenceChange(level, matchResult.confidence);

     return this.scrollState;
   }
   ```

5. **Add handleMatch(matchResult) method:**
   Handles skip detection and position updates:
   ```javascript
   handleMatch(matchResult) {
     const distance = matchResult.position - this.targetWordIndex;
     const absDistance = Math.abs(distance);
     const isForward = distance > 0;

     // Check if this is a significant skip
     if (absDistance > 5) { // More than 5 words difference
       const requiredConfidence = isForward
         ? this.forwardSkipConfidence
         : this.backwardSkipConfidence;

       // Reject low-confidence skips
       if (matchResult.confidence < requiredConfidence) {
         return; // Don't update position
       }

       // Determine animation type
       if (absDistance >= this.longSkipThreshold) {
         // Instant jump for long skips
         this.targetWordIndex = matchResult.position;
         // Reset speed for fresh start
         this.currentSpeed = this.baseSpeed;
       } else {
         // Smooth scroll for short skips
         this.targetWordIndex = matchResult.position;
       }
     } else {
       // Normal incremental update
       this.targetWordIndex = matchResult.position;
     }

     this.lastMatchTime = Date.now();
     this.lastWordIndex = matchResult.position;
     this.totalWords = this.totalWords || matchResult.position + 100; // Estimate if not set

     if (!this.isScrolling) {
       this.startScrolling();
     }
   }
   ```

6. **Add exponential easing methods:**
   ```javascript
   easeToward(current, target, deltaMs, timeConstant) {
     const factor = 1 - Math.exp(-deltaMs / timeConstant);
     return current + (target - current) * factor;
   }
   ```

7. **Rewrite tick() method with state-aware behavior:**
   ```javascript
   tick() {
     if (!this.isScrolling) return;

     const now = performance.now();
     const deltaTime = (now - this.lastFrameTime) / 1000;
     const deltaMs = (now - this.lastFrameTime);
     this.lastFrameTime = now;

     const maxScroll = this.container.scrollHeight - this.container.clientHeight;
     const currentScroll = this.container.scrollTop;

     // Calculate scroll boundary - never scroll past last matched position
     const boundaryScroll = (this.lastMatchedPosition / this.totalWords) * maxScroll;

     // Determine target speed based on state
     let targetSpeed;
     switch (this.scrollState) {
       case ScrollState.CONFIDENT:
         // Full speed based on speaking pace
         targetSpeed = this.calculatePaceBasedSpeed();
         this.currentSpeed = this.easeToward(this.currentSpeed, targetSpeed, deltaMs, this.accelerationTimeConstant);
         break;

       case ScrollState.UNCERTAIN:
         // Slow down gradually
         targetSpeed = this.baseSpeed * 0.3;
         this.currentSpeed = this.easeToward(this.currentSpeed, targetSpeed, deltaMs, this.decelerationTimeConstant);
         break;

       case ScrollState.OFF_SCRIPT:
         // Coast to stop
         this.currentSpeed = this.easeToward(this.currentSpeed, 0, deltaMs, this.decelerationTimeConstant);
         if (this.currentSpeed < 1) {
           this.currentSpeed = 0;
         }
         break;
     }

     // Calculate new scroll position
     const pixelsToScroll = this.currentSpeed * deltaTime;
     let newScrollTop = currentScroll + pixelsToScroll;

     // CRITICAL: Never scroll past the boundary (last spoken position)
     if (newScrollTop > boundaryScroll) {
       newScrollTop = boundaryScroll;
       // If we hit the boundary and we're off-script, stop
       if (this.scrollState === ScrollState.OFF_SCRIPT) {
         this.currentSpeed = 0;
       }
     }

     // Clamp to valid range
     if (newScrollTop >= maxScroll) {
       this.container.scrollTop = maxScroll;
       this.stopScrolling();
       return;
     }

     this.container.scrollTop = Math.max(0, newScrollTop);

     this.animationId = requestAnimationFrame(() => this.tick());
   }
   ```

8. **Add calculatePaceBasedSpeed() helper:**
   ```javascript
   calculatePaceBasedSpeed() {
     if (this.totalWords === 0) return this.baseSpeed;

     const maxScroll = this.container.scrollHeight - this.container.clientHeight;
     const pixelsPerWord = maxScroll / this.totalWords;
     const paceBasedSpeed = this.speakingPace * pixelsPerWord;

     // No speed cap per CONTEXT.md
     return Math.max(paceBasedSpeed, this.baseSpeed * 0.5);
   }
   ```

9. **Update reset() to reset new state:**
   ```javascript
   reset() {
     this.stop();
     this.targetWordIndex = 0;
     this.lastWordIndex = 0;
     this.lastMatchTime = 0;
     this.speakingPace = 0;
     this.currentSpeed = 0;
     this.totalWords = 0;
     this.scrollState = ScrollState.CONFIDENT;
     this.uncertainStartTime = null;
     this.lastMatchedPosition = 0;
   }
   ```

10. **Update getState() for debugging:**
    ```javascript
    getState() {
      return {
        targetWordIndex: this.targetWordIndex,
        speakingPace: this.speakingPace.toFixed(1),
        currentSpeed: this.currentSpeed.toFixed(0),
        isScrolling: this.isScrolling,
        scrollState: this.scrollState,
        lastMatchedPosition: this.lastMatchedPosition
      };
    }
    ```
  </action>
  <verify>
In ScrollSync.js:
- ScrollState enum exported with CONFIDENT, UNCERTAIN, OFF_SCRIPT
- updateConfidence method exists
- handleMatch method with skip detection
- easeToward method with exponential decay (Math.exp)
- tick() respects boundary (lastMatchedPosition)
- State transitions follow pattern: CONFIDENT <-> UNCERTAIN -> OFF_SCRIPT -> CONFIDENT
  </verify>
  <done>
ScrollSync implements state machine with 3 states, exponential easing for speed changes, skip detection with confidence thresholds, and boundary enforcement (never scrolls past last matched position)
  </done>
</task>

</tasks>

<verification>
1. TextMatcher has getMatchWithConfidence() that returns {position, confidence, level}
2. ScrollSync exports ScrollState enum
3. ScrollSync.updateConfidence() transitions between states
4. `grep "Math.exp" matching/ScrollSync.js` returns matches (exponential easing)
5. ScrollSync.tick() checks lastMatchedPosition boundary
</verification>

<success_criteria>
- TextMatcher returns confidence data with every match attempt
- ScrollSync state machine correctly transitions: high confidence -> CONFIDENT, low confidence for 4+ seconds -> OFF_SCRIPT
- Skip detection requires 0.85 confidence for forward, 0.92 for backward
- Scroll position never exceeds lastMatchedPosition boundary
- Speed changes use exponential easing (smooth, not instant)
</success_criteria>

<output>
After completion, create `.planning/phases/04-intelligent-scroll-control/04-03-SUMMARY.md`
</output>
